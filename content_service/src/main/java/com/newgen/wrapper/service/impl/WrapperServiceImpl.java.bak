package com.newgen.wrapper.service.impl;

import java.util.Map;

import javax.servlet.http.HttpServletRequest;

import org.json.JSONArray;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Profile;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.util.UriComponentsBuilder;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.newgen.controller.ContentController;
import com.newgen.controller.ExceptionThrower;
import com.newgen.dto.ContentDTO;
import com.newgen.dto.StoreContentDTO;
import com.newgen.exception.CustomException;
import com.newgen.wrapper.service.WrapperService;

@Component
@Profile({ "production", "default" })
public class WrapperServiceImpl extends ExceptionThrower implements WrapperService {

	private static final Logger logger = LoggerFactory.getLogger(ContentController.class);

	@Value("${metadata.service.url}")
	private String metadataUrl;

	@Value("${storage.service.url}")
	private String storageUrl;

	private String contentApiPath = "/content";

	private String contentLocationApiPath = "/contentlocation";

	private String storeApiPath = "/store";

	private String versionParam = "version";

	@Autowired
	private RestTemplate restTemplate;

	// Save the uploaded file to this folder
	@Value("${upload.folder}")
	private String UPLOADED_FOLDER;

	private String containerName = "testcontainer";

	private String storageType = "AZURE_BLOB";

	public ResponseEntity<String> uploadStoreContent(MultipartFile file, String name, String contentType,
			String comments, String parentFolderId, String ownerName, String ownerId, String storageCredentialId,
			String uploadPath) throws CustomException, JsonProcessingException, InterruptedException {
		ObjectMapper mapper = new ObjectMapper();
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_JSON);
		ResponseEntity<String> response;

		// Upload the file using storage service
		StoreContentDTO storeContentDTO = new StoreContentDTO();
		storeContentDTO.setStorageCredentialId(storageCredentialId);
		storeContentDTO.setContentPath(uploadPath);
		storeContentDTO.setContainerName(containerName);
		storeContentDTO.setType(storageType);

		HttpEntity<String> request = new HttpEntity<>(mapper.writeValueAsString(storeContentDTO), headers);
		response = restTemplate.exchange(storageUrl + storeApiPath + "/upload", HttpMethod.POST, request, String.class);

		return new ResponseEntity<>(response.getBody(), response.getStatusCode());
	}

	public ResponseEntity<String> uploadMetaContent(MultipartFile file, String name, String contentType,
			String comments, String parentFolderId, String ownerName, String ownerId, String storageCredentialId,
			String token) throws CustomException, JsonProcessingException, InterruptedException {
		ObjectMapper mapper = new ObjectMapper();
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_JSON);
		ResponseEntity<String> response;

		// Create temporary content metadata by calling the metadata
		// service api
		// Create the contentDTO object
		ContentDTO contentDTO = new ContentDTO();
		contentDTO.setName(name);
		contentDTO.setContentType(contentType);
		contentDTO.setComments(comments);
		contentDTO.setParentFolderId(parentFolderId);
		contentDTO.setOwnerId(ownerId);
		contentDTO.setOwnerName(ownerName);
		// contentDTO.setContentLocationId(contentLocationId);
		contentDTO.setToken(token);

		HttpEntity<String> request = new HttpEntity<>(mapper.writeValueAsString(contentDTO), headers);
		response = restTemplate.exchange(metadataUrl + contentApiPath, HttpMethod.POST, request, String.class);
		// Send the response as an output

		return new ResponseEntity<>(response.getBody(), response.getStatusCode());
	}

	public ResponseEntity<String> deleteContent(String id, String version) {
		// Query parameters
		UriComponentsBuilder builder = UriComponentsBuilder.fromUriString(metadataUrl + contentApiPath + "/" + id);
		// Add query parameter
		if (version != null && !version.isEmpty()) {
			builder.queryParam(versionParam, version);
		}
		ResponseEntity<String> response = restTemplate.exchange(builder.toUriString(), HttpMethod.DELETE, null,
				String.class);
		return new ResponseEntity<>(response.getBody(), response.getStatusCode());
	}

	public ResponseEntity<String> searchContents(HttpServletRequest request) {
		// Query parameters
		UriComponentsBuilder builder = UriComponentsBuilder.fromUriString(metadataUrl + contentApiPath);
		// Add query parameter
		for (Map.Entry<String, String[]> entry : request.getParameterMap().entrySet()) {
			builder.queryParam(entry.getKey(), entry.getValue()[0]);
		}
		ResponseEntity<String> response = restTemplate.exchange(builder.toUriString(), HttpMethod.GET, null,
				String.class);
		return new ResponseEntity<>(response.getBody(), response.getStatusCode());
	}

	public ResponseEntity<String> updateContentInfo(String updateContentParams, String id, Long version) {
		// Query parameters
		UriComponentsBuilder builder = UriComponentsBuilder.fromUriString(metadataUrl + contentApiPath + "/" + id);
		// Add query parameter
		if (version != null) {
			builder.queryParam(versionParam, version);
		}

		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_JSON);
		HttpEntity<String> request = new HttpEntity<>(updateContentParams, headers);

		ResponseEntity<String> response = restTemplate.exchange(builder.toUriString(), HttpMethod.PUT, request,
				String.class);
		return new ResponseEntity<>(response.getBody(), response.getStatusCode());
	}

	public ResponseEntity<String> copyContent(String parentFolderId, String id) {
		// Query parameters
		UriComponentsBuilder builder = UriComponentsBuilder.fromUriString(metadataUrl + contentApiPath + "/" + id);
		// Add query parameter
		if (parentFolderId != null) {
			builder.queryParam("parentFolderId", parentFolderId);
		}

		ResponseEntity<String> response = restTemplate.exchange(builder.toUriString(), HttpMethod.POST, null,
				String.class);
		return new ResponseEntity<>(response.getBody(), response.getStatusCode());
	}

	public ResponseEntity<String> moveContent(String id, String targetFolderId, Long version) {
		// Query parameters
		UriComponentsBuilder builder = UriComponentsBuilder
				.fromUriString(metadataUrl + contentApiPath + "/move/" + id + "/" + targetFolderId);
		// Add query parameter
		if (version != null) {
			builder.queryParam(versionParam, version);
		}
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_JSON);
		HttpEntity<String> request = new HttpEntity<>("", headers);
		ResponseEntity<String> response = restTemplate.exchange(builder.toUriString(), HttpMethod.POST, request,
				String.class);
		return new ResponseEntity<>(response.getBody(), response.getStatusCode());
	}

	public ResponseEntity<String> contentStatus(String id) {
		// Query parameters
		UriComponentsBuilder builder = UriComponentsBuilder.fromUriString(metadataUrl + contentApiPath);
		// Add query parameter
		if (id != null) {
			builder.queryParam("id", id);
			builder.queryParam("ignoreCommittedFlag", "true");
		}
		ResponseEntity<String> response = restTemplate.exchange(builder.toUriString(), HttpMethod.GET, null,
				String.class);
		return new ResponseEntity<>(response.getBody(), response.getStatusCode());
	}

	public ResponseEntity<String> getContentUploadStatus(String token) {
		// Query parameters
		UriComponentsBuilder builder = UriComponentsBuilder.fromUriString(storageUrl + "/store/status");
		// Add query parameter
		if (token != null) {
			builder.queryParam("token", token);
		}
		ResponseEntity<String> response = restTemplate.exchange(builder.toUriString(), HttpMethod.GET, null,
				String.class);

		return new ResponseEntity<>(response.getBody(), response.getStatusCode());
	}

	public ResponseEntity<String> retrieveContent(String id) throws CustomException {
		logger.debug("Entering retrieveContent()");
		// Fetch contentMetadata from contentid

		// Query parameters
		UriComponentsBuilder builder = UriComponentsBuilder.fromUriString(metadataUrl + contentApiPath);
		// Add query parameter
		builder.queryParam("id", id);
		ResponseEntity<String> response = restTemplate.exchange(builder.toUriString(), HttpMethod.GET, null,
				String.class);
		if (response.getStatusCode() == HttpStatus.OK) {
			JSONArray jsonArr = new JSONArray(response.getBody());
			if (jsonArr.length() > 0) {
				JSONObject jsonObj = (JSONObject) jsonArr.get(0);
				String contentLocationId = jsonObj.get("contentLocationId").toString();
				// Fetch contentLocation object from contentLocationId
				response = restTemplate.exchange(metadataUrl + contentLocationApiPath + "/" + contentLocationId,
						HttpMethod.GET, null, String.class);
				if (response.getStatusCode() == HttpStatus.OK) {
					jsonObj = new JSONObject(response.getBody());
					String storageLocationId = jsonObj.get("locationId").toString();
					// Fetch downloadUrl by sending the storageLocationId from
					// contentLocationObject
					response = restTemplate.exchange(storageUrl + "/store/retrieve/" + storageLocationId,
							HttpMethod.GET, null, String.class);
				}
			} else {
				throwContentNotFoundException();
			}
		}

		logger.debug("Exit retrieveContent()");
		return new ResponseEntity<>(response.getBody(), response.getStatusCode());
	}

}
